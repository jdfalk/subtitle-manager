// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.6
// 	protoc        (unknown)
// source: file/v1/file_service.proto

package v1

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// File Upload/Download Messages
type UploadFileRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to Request:
	//
	//	*UploadFileRequest_Metadata
	//	*UploadFileRequest_Chunk
	Request       isUploadFileRequest_Request `protobuf_oneof:"request"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *UploadFileRequest) Reset() {
	*x = UploadFileRequest{}
	mi := &file_file_v1_file_service_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *UploadFileRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UploadFileRequest) ProtoMessage() {}

func (x *UploadFileRequest) ProtoReflect() protoreflect.Message {
	mi := &file_file_v1_file_service_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use UploadFileRequest.ProtoReflect.Descriptor instead.
func (*UploadFileRequest) Descriptor() ([]byte, []int) {
	return file_file_v1_file_service_proto_rawDescGZIP(), []int{0}
}

func (x *UploadFileRequest) GetRequest() isUploadFileRequest_Request {
	if x != nil {
		return x.Request
	}
	return nil
}

func (x *UploadFileRequest) GetMetadata() *FileMetadata {
	if x != nil {
		if x, ok := x.Request.(*UploadFileRequest_Metadata); ok {
			return x.Metadata
		}
	}
	return nil
}

func (x *UploadFileRequest) GetChunk() *FileChunk {
	if x != nil {
		if x, ok := x.Request.(*UploadFileRequest_Chunk); ok {
			return x.Chunk
		}
	}
	return nil
}

type isUploadFileRequest_Request interface {
	isUploadFileRequest_Request()
}

type UploadFileRequest_Metadata struct {
	Metadata *FileMetadata `protobuf:"bytes,1,opt,name=metadata,oneof"`
}

type UploadFileRequest_Chunk struct {
	Chunk *FileChunk `protobuf:"bytes,2,opt,name=chunk,oneof"`
}

func (*UploadFileRequest_Metadata) isUploadFileRequest_Request() {}

func (*UploadFileRequest_Chunk) isUploadFileRequest_Request() {}

type FileMetadata struct {
	state          protoimpl.MessageState `protogen:"open.v1"`
	Filename       *string                `protobuf:"bytes,1,opt,name=filename" json:"filename,omitempty"`
	ContentType    *string                `protobuf:"bytes,2,opt,name=content_type,json=contentType" json:"content_type,omitempty"`
	TotalSize      *int64                 `protobuf:"varint,3,opt,name=total_size,json=totalSize" json:"total_size,omitempty"`
	UserId         *string                `protobuf:"bytes,4,opt,name=user_id,json=userId" json:"user_id,omitempty"`
	CustomMetadata map[string]string      `protobuf:"bytes,5,rep,name=custom_metadata,json=customMetadata" json:"custom_metadata,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *FileMetadata) Reset() {
	*x = FileMetadata{}
	mi := &file_file_v1_file_service_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *FileMetadata) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FileMetadata) ProtoMessage() {}

func (x *FileMetadata) ProtoReflect() protoreflect.Message {
	mi := &file_file_v1_file_service_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FileMetadata.ProtoReflect.Descriptor instead.
func (*FileMetadata) Descriptor() ([]byte, []int) {
	return file_file_v1_file_service_proto_rawDescGZIP(), []int{1}
}

func (x *FileMetadata) GetFilename() string {
	if x != nil && x.Filename != nil {
		return *x.Filename
	}
	return ""
}

func (x *FileMetadata) GetContentType() string {
	if x != nil && x.ContentType != nil {
		return *x.ContentType
	}
	return ""
}

func (x *FileMetadata) GetTotalSize() int64 {
	if x != nil && x.TotalSize != nil {
		return *x.TotalSize
	}
	return 0
}

func (x *FileMetadata) GetUserId() string {
	if x != nil && x.UserId != nil {
		return *x.UserId
	}
	return ""
}

func (x *FileMetadata) GetCustomMetadata() map[string]string {
	if x != nil {
		return x.CustomMetadata
	}
	return nil
}

type FileChunk struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Data          []byte                 `protobuf:"bytes,1,opt,name=data" json:"data,omitempty"`
	Offset        *int64                 `protobuf:"varint,2,opt,name=offset" json:"offset,omitempty"`
	IsLast        *bool                  `protobuf:"varint,3,opt,name=is_last,json=isLast" json:"is_last,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *FileChunk) Reset() {
	*x = FileChunk{}
	mi := &file_file_v1_file_service_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *FileChunk) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FileChunk) ProtoMessage() {}

func (x *FileChunk) ProtoReflect() protoreflect.Message {
	mi := &file_file_v1_file_service_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FileChunk.ProtoReflect.Descriptor instead.
func (*FileChunk) Descriptor() ([]byte, []int) {
	return file_file_v1_file_service_proto_rawDescGZIP(), []int{2}
}

func (x *FileChunk) GetData() []byte {
	if x != nil {
		return x.Data
	}
	return nil
}

func (x *FileChunk) GetOffset() int64 {
	if x != nil && x.Offset != nil {
		return *x.Offset
	}
	return 0
}

func (x *FileChunk) GetIsLast() bool {
	if x != nil && x.IsLast != nil {
		return *x.IsLast
	}
	return false
}

type UploadFileResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	FileId        *string                `protobuf:"bytes,1,opt,name=file_id,json=fileId" json:"file_id,omitempty"`
	Filename      *string                `protobuf:"bytes,2,opt,name=filename" json:"filename,omitempty"`
	Size          *int64                 `protobuf:"varint,3,opt,name=size" json:"size,omitempty"`
	Success       *bool                  `protobuf:"varint,4,opt,name=success" json:"success,omitempty"`
	ErrorMessage  *string                `protobuf:"bytes,5,opt,name=error_message,json=errorMessage" json:"error_message,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *UploadFileResponse) Reset() {
	*x = UploadFileResponse{}
	mi := &file_file_v1_file_service_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *UploadFileResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UploadFileResponse) ProtoMessage() {}

func (x *UploadFileResponse) ProtoReflect() protoreflect.Message {
	mi := &file_file_v1_file_service_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use UploadFileResponse.ProtoReflect.Descriptor instead.
func (*UploadFileResponse) Descriptor() ([]byte, []int) {
	return file_file_v1_file_service_proto_rawDescGZIP(), []int{3}
}

func (x *UploadFileResponse) GetFileId() string {
	if x != nil && x.FileId != nil {
		return *x.FileId
	}
	return ""
}

func (x *UploadFileResponse) GetFilename() string {
	if x != nil && x.Filename != nil {
		return *x.Filename
	}
	return ""
}

func (x *UploadFileResponse) GetSize() int64 {
	if x != nil && x.Size != nil {
		return *x.Size
	}
	return 0
}

func (x *UploadFileResponse) GetSuccess() bool {
	if x != nil && x.Success != nil {
		return *x.Success
	}
	return false
}

func (x *UploadFileResponse) GetErrorMessage() string {
	if x != nil && x.ErrorMessage != nil {
		return *x.ErrorMessage
	}
	return ""
}

type DownloadFileRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	RequestId     *string                `protobuf:"bytes,1,opt,name=request_id,json=requestId" json:"request_id,omitempty"`
	FileId        *string                `protobuf:"bytes,2,opt,name=file_id,json=fileId" json:"file_id,omitempty"`
	Offset        *int64                 `protobuf:"varint,3,opt,name=offset" json:"offset,omitempty"`
	Length        *int64                 `protobuf:"varint,4,opt,name=length" json:"length,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DownloadFileRequest) Reset() {
	*x = DownloadFileRequest{}
	mi := &file_file_v1_file_service_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DownloadFileRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DownloadFileRequest) ProtoMessage() {}

func (x *DownloadFileRequest) ProtoReflect() protoreflect.Message {
	mi := &file_file_v1_file_service_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DownloadFileRequest.ProtoReflect.Descriptor instead.
func (*DownloadFileRequest) Descriptor() ([]byte, []int) {
	return file_file_v1_file_service_proto_rawDescGZIP(), []int{4}
}

func (x *DownloadFileRequest) GetRequestId() string {
	if x != nil && x.RequestId != nil {
		return *x.RequestId
	}
	return ""
}

func (x *DownloadFileRequest) GetFileId() string {
	if x != nil && x.FileId != nil {
		return *x.FileId
	}
	return ""
}

func (x *DownloadFileRequest) GetOffset() int64 {
	if x != nil && x.Offset != nil {
		return *x.Offset
	}
	return 0
}

func (x *DownloadFileRequest) GetLength() int64 {
	if x != nil && x.Length != nil {
		return *x.Length
	}
	return 0
}

type DownloadFileResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to Response:
	//
	//	*DownloadFileResponse_FileInfo
	//	*DownloadFileResponse_Chunk
	Response      isDownloadFileResponse_Response `protobuf_oneof:"response"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DownloadFileResponse) Reset() {
	*x = DownloadFileResponse{}
	mi := &file_file_v1_file_service_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DownloadFileResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DownloadFileResponse) ProtoMessage() {}

func (x *DownloadFileResponse) ProtoReflect() protoreflect.Message {
	mi := &file_file_v1_file_service_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DownloadFileResponse.ProtoReflect.Descriptor instead.
func (*DownloadFileResponse) Descriptor() ([]byte, []int) {
	return file_file_v1_file_service_proto_rawDescGZIP(), []int{5}
}

func (x *DownloadFileResponse) GetResponse() isDownloadFileResponse_Response {
	if x != nil {
		return x.Response
	}
	return nil
}

func (x *DownloadFileResponse) GetFileInfo() *FileInfo {
	if x != nil {
		if x, ok := x.Response.(*DownloadFileResponse_FileInfo); ok {
			return x.FileInfo
		}
	}
	return nil
}

func (x *DownloadFileResponse) GetChunk() *FileChunk {
	if x != nil {
		if x, ok := x.Response.(*DownloadFileResponse_Chunk); ok {
			return x.Chunk
		}
	}
	return nil
}

type isDownloadFileResponse_Response interface {
	isDownloadFileResponse_Response()
}

type DownloadFileResponse_FileInfo struct {
	FileInfo *FileInfo `protobuf:"bytes,1,opt,name=file_info,json=fileInfo,oneof"`
}

type DownloadFileResponse_Chunk struct {
	Chunk *FileChunk `protobuf:"bytes,2,opt,name=chunk,oneof"`
}

func (*DownloadFileResponse_FileInfo) isDownloadFileResponse_Response() {}

func (*DownloadFileResponse_Chunk) isDownloadFileResponse_Response() {}

type FileInfo struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Filename      *string                `protobuf:"bytes,1,opt,name=filename" json:"filename,omitempty"`
	ContentType   *string                `protobuf:"bytes,2,opt,name=content_type,json=contentType" json:"content_type,omitempty"`
	TotalSize     *int64                 `protobuf:"varint,3,opt,name=total_size,json=totalSize" json:"total_size,omitempty"`
	Metadata      map[string]string      `protobuf:"bytes,4,rep,name=metadata" json:"metadata,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *FileInfo) Reset() {
	*x = FileInfo{}
	mi := &file_file_v1_file_service_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *FileInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FileInfo) ProtoMessage() {}

func (x *FileInfo) ProtoReflect() protoreflect.Message {
	mi := &file_file_v1_file_service_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FileInfo.ProtoReflect.Descriptor instead.
func (*FileInfo) Descriptor() ([]byte, []int) {
	return file_file_v1_file_service_proto_rawDescGZIP(), []int{6}
}

func (x *FileInfo) GetFilename() string {
	if x != nil && x.Filename != nil {
		return *x.Filename
	}
	return ""
}

func (x *FileInfo) GetContentType() string {
	if x != nil && x.ContentType != nil {
		return *x.ContentType
	}
	return ""
}

func (x *FileInfo) GetTotalSize() int64 {
	if x != nil && x.TotalSize != nil {
		return *x.TotalSize
	}
	return 0
}

func (x *FileInfo) GetMetadata() map[string]string {
	if x != nil {
		return x.Metadata
	}
	return nil
}

// File Management Messages
type DeleteFileRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	RequestId     *string                `protobuf:"bytes,1,opt,name=request_id,json=requestId" json:"request_id,omitempty"`
	FileId        *string                `protobuf:"bytes,2,opt,name=file_id,json=fileId" json:"file_id,omitempty"`
	Permanent     *bool                  `protobuf:"varint,3,opt,name=permanent" json:"permanent,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DeleteFileRequest) Reset() {
	*x = DeleteFileRequest{}
	mi := &file_file_v1_file_service_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DeleteFileRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DeleteFileRequest) ProtoMessage() {}

func (x *DeleteFileRequest) ProtoReflect() protoreflect.Message {
	mi := &file_file_v1_file_service_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DeleteFileRequest.ProtoReflect.Descriptor instead.
func (*DeleteFileRequest) Descriptor() ([]byte, []int) {
	return file_file_v1_file_service_proto_rawDescGZIP(), []int{7}
}

func (x *DeleteFileRequest) GetRequestId() string {
	if x != nil && x.RequestId != nil {
		return *x.RequestId
	}
	return ""
}

func (x *DeleteFileRequest) GetFileId() string {
	if x != nil && x.FileId != nil {
		return *x.FileId
	}
	return ""
}

func (x *DeleteFileRequest) GetPermanent() bool {
	if x != nil && x.Permanent != nil {
		return *x.Permanent
	}
	return false
}

type DeleteFileResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	FileId        *string                `protobuf:"bytes,1,opt,name=file_id,json=fileId" json:"file_id,omitempty"`
	Deleted       *bool                  `protobuf:"varint,2,opt,name=deleted" json:"deleted,omitempty"`
	Success       *bool                  `protobuf:"varint,3,opt,name=success" json:"success,omitempty"`
	ErrorMessage  *string                `protobuf:"bytes,4,opt,name=error_message,json=errorMessage" json:"error_message,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DeleteFileResponse) Reset() {
	*x = DeleteFileResponse{}
	mi := &file_file_v1_file_service_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DeleteFileResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DeleteFileResponse) ProtoMessage() {}

func (x *DeleteFileResponse) ProtoReflect() protoreflect.Message {
	mi := &file_file_v1_file_service_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DeleteFileResponse.ProtoReflect.Descriptor instead.
func (*DeleteFileResponse) Descriptor() ([]byte, []int) {
	return file_file_v1_file_service_proto_rawDescGZIP(), []int{8}
}

func (x *DeleteFileResponse) GetFileId() string {
	if x != nil && x.FileId != nil {
		return *x.FileId
	}
	return ""
}

func (x *DeleteFileResponse) GetDeleted() bool {
	if x != nil && x.Deleted != nil {
		return *x.Deleted
	}
	return false
}

func (x *DeleteFileResponse) GetSuccess() bool {
	if x != nil && x.Success != nil {
		return *x.Success
	}
	return false
}

func (x *DeleteFileResponse) GetErrorMessage() string {
	if x != nil && x.ErrorMessage != nil {
		return *x.ErrorMessage
	}
	return ""
}

type GetFileInfoRequest struct {
	state           protoimpl.MessageState `protogen:"open.v1"`
	RequestId       *string                `protobuf:"bytes,1,opt,name=request_id,json=requestId" json:"request_id,omitempty"`
	FileId          *string                `protobuf:"bytes,2,opt,name=file_id,json=fileId" json:"file_id,omitempty"`
	IncludeMetadata *bool                  `protobuf:"varint,3,opt,name=include_metadata,json=includeMetadata" json:"include_metadata,omitempty"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *GetFileInfoRequest) Reset() {
	*x = GetFileInfoRequest{}
	mi := &file_file_v1_file_service_proto_msgTypes[9]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetFileInfoRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetFileInfoRequest) ProtoMessage() {}

func (x *GetFileInfoRequest) ProtoReflect() protoreflect.Message {
	mi := &file_file_v1_file_service_proto_msgTypes[9]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetFileInfoRequest.ProtoReflect.Descriptor instead.
func (*GetFileInfoRequest) Descriptor() ([]byte, []int) {
	return file_file_v1_file_service_proto_rawDescGZIP(), []int{9}
}

func (x *GetFileInfoRequest) GetRequestId() string {
	if x != nil && x.RequestId != nil {
		return *x.RequestId
	}
	return ""
}

func (x *GetFileInfoRequest) GetFileId() string {
	if x != nil && x.FileId != nil {
		return *x.FileId
	}
	return ""
}

func (x *GetFileInfoRequest) GetIncludeMetadata() bool {
	if x != nil && x.IncludeMetadata != nil {
		return *x.IncludeMetadata
	}
	return false
}

type GetFileInfoResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	FileId        *string                `protobuf:"bytes,1,opt,name=file_id,json=fileId" json:"file_id,omitempty"`
	Filename      *string                `protobuf:"bytes,2,opt,name=filename" json:"filename,omitempty"`
	ContentType   *string                `protobuf:"bytes,3,opt,name=content_type,json=contentType" json:"content_type,omitempty"`
	Size          *int64                 `protobuf:"varint,4,opt,name=size" json:"size,omitempty"`
	CreatedAt     *string                `protobuf:"bytes,5,opt,name=created_at,json=createdAt" json:"created_at,omitempty"`
	ModifiedAt    *string                `protobuf:"bytes,6,opt,name=modified_at,json=modifiedAt" json:"modified_at,omitempty"`
	UserId        *string                `protobuf:"bytes,7,opt,name=user_id,json=userId" json:"user_id,omitempty"`
	Metadata      map[string]string      `protobuf:"bytes,8,rep,name=metadata" json:"metadata,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	Success       *bool                  `protobuf:"varint,9,opt,name=success" json:"success,omitempty"`
	ErrorMessage  *string                `protobuf:"bytes,10,opt,name=error_message,json=errorMessage" json:"error_message,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetFileInfoResponse) Reset() {
	*x = GetFileInfoResponse{}
	mi := &file_file_v1_file_service_proto_msgTypes[10]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetFileInfoResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetFileInfoResponse) ProtoMessage() {}

func (x *GetFileInfoResponse) ProtoReflect() protoreflect.Message {
	mi := &file_file_v1_file_service_proto_msgTypes[10]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetFileInfoResponse.ProtoReflect.Descriptor instead.
func (*GetFileInfoResponse) Descriptor() ([]byte, []int) {
	return file_file_v1_file_service_proto_rawDescGZIP(), []int{10}
}

func (x *GetFileInfoResponse) GetFileId() string {
	if x != nil && x.FileId != nil {
		return *x.FileId
	}
	return ""
}

func (x *GetFileInfoResponse) GetFilename() string {
	if x != nil && x.Filename != nil {
		return *x.Filename
	}
	return ""
}

func (x *GetFileInfoResponse) GetContentType() string {
	if x != nil && x.ContentType != nil {
		return *x.ContentType
	}
	return ""
}

func (x *GetFileInfoResponse) GetSize() int64 {
	if x != nil && x.Size != nil {
		return *x.Size
	}
	return 0
}

func (x *GetFileInfoResponse) GetCreatedAt() string {
	if x != nil && x.CreatedAt != nil {
		return *x.CreatedAt
	}
	return ""
}

func (x *GetFileInfoResponse) GetModifiedAt() string {
	if x != nil && x.ModifiedAt != nil {
		return *x.ModifiedAt
	}
	return ""
}

func (x *GetFileInfoResponse) GetUserId() string {
	if x != nil && x.UserId != nil {
		return *x.UserId
	}
	return ""
}

func (x *GetFileInfoResponse) GetMetadata() map[string]string {
	if x != nil {
		return x.Metadata
	}
	return nil
}

func (x *GetFileInfoResponse) GetSuccess() bool {
	if x != nil && x.Success != nil {
		return *x.Success
	}
	return false
}

func (x *GetFileInfoResponse) GetErrorMessage() string {
	if x != nil && x.ErrorMessage != nil {
		return *x.ErrorMessage
	}
	return ""
}

// File Operations Messages
type CopyFileRequest struct {
	state           protoimpl.MessageState `protogen:"open.v1"`
	RequestId       *string                `protobuf:"bytes,1,opt,name=request_id,json=requestId" json:"request_id,omitempty"`
	SourceFileId    *string                `protobuf:"bytes,2,opt,name=source_file_id,json=sourceFileId" json:"source_file_id,omitempty"`
	DestinationName *string                `protobuf:"bytes,3,opt,name=destination_name,json=destinationName" json:"destination_name,omitempty"`
	UserId          *string                `protobuf:"bytes,4,opt,name=user_id,json=userId" json:"user_id,omitempty"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *CopyFileRequest) Reset() {
	*x = CopyFileRequest{}
	mi := &file_file_v1_file_service_proto_msgTypes[11]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CopyFileRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CopyFileRequest) ProtoMessage() {}

func (x *CopyFileRequest) ProtoReflect() protoreflect.Message {
	mi := &file_file_v1_file_service_proto_msgTypes[11]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CopyFileRequest.ProtoReflect.Descriptor instead.
func (*CopyFileRequest) Descriptor() ([]byte, []int) {
	return file_file_v1_file_service_proto_rawDescGZIP(), []int{11}
}

func (x *CopyFileRequest) GetRequestId() string {
	if x != nil && x.RequestId != nil {
		return *x.RequestId
	}
	return ""
}

func (x *CopyFileRequest) GetSourceFileId() string {
	if x != nil && x.SourceFileId != nil {
		return *x.SourceFileId
	}
	return ""
}

func (x *CopyFileRequest) GetDestinationName() string {
	if x != nil && x.DestinationName != nil {
		return *x.DestinationName
	}
	return ""
}

func (x *CopyFileRequest) GetUserId() string {
	if x != nil && x.UserId != nil {
		return *x.UserId
	}
	return ""
}

type CopyFileResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	NewFileId     *string                `protobuf:"bytes,1,opt,name=new_file_id,json=newFileId" json:"new_file_id,omitempty"`
	Filename      *string                `protobuf:"bytes,2,opt,name=filename" json:"filename,omitempty"`
	Success       *bool                  `protobuf:"varint,3,opt,name=success" json:"success,omitempty"`
	ErrorMessage  *string                `protobuf:"bytes,4,opt,name=error_message,json=errorMessage" json:"error_message,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CopyFileResponse) Reset() {
	*x = CopyFileResponse{}
	mi := &file_file_v1_file_service_proto_msgTypes[12]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CopyFileResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CopyFileResponse) ProtoMessage() {}

func (x *CopyFileResponse) ProtoReflect() protoreflect.Message {
	mi := &file_file_v1_file_service_proto_msgTypes[12]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CopyFileResponse.ProtoReflect.Descriptor instead.
func (*CopyFileResponse) Descriptor() ([]byte, []int) {
	return file_file_v1_file_service_proto_rawDescGZIP(), []int{12}
}

func (x *CopyFileResponse) GetNewFileId() string {
	if x != nil && x.NewFileId != nil {
		return *x.NewFileId
	}
	return ""
}

func (x *CopyFileResponse) GetFilename() string {
	if x != nil && x.Filename != nil {
		return *x.Filename
	}
	return ""
}

func (x *CopyFileResponse) GetSuccess() bool {
	if x != nil && x.Success != nil {
		return *x.Success
	}
	return false
}

func (x *CopyFileResponse) GetErrorMessage() string {
	if x != nil && x.ErrorMessage != nil {
		return *x.ErrorMessage
	}
	return ""
}

type MoveFileRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	RequestId     *string                `protobuf:"bytes,1,opt,name=request_id,json=requestId" json:"request_id,omitempty"`
	FileId        *string                `protobuf:"bytes,2,opt,name=file_id,json=fileId" json:"file_id,omitempty"`
	NewName       *string                `protobuf:"bytes,3,opt,name=new_name,json=newName" json:"new_name,omitempty"`
	NewLocation   *string                `protobuf:"bytes,4,opt,name=new_location,json=newLocation" json:"new_location,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *MoveFileRequest) Reset() {
	*x = MoveFileRequest{}
	mi := &file_file_v1_file_service_proto_msgTypes[13]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *MoveFileRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MoveFileRequest) ProtoMessage() {}

func (x *MoveFileRequest) ProtoReflect() protoreflect.Message {
	mi := &file_file_v1_file_service_proto_msgTypes[13]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use MoveFileRequest.ProtoReflect.Descriptor instead.
func (*MoveFileRequest) Descriptor() ([]byte, []int) {
	return file_file_v1_file_service_proto_rawDescGZIP(), []int{13}
}

func (x *MoveFileRequest) GetRequestId() string {
	if x != nil && x.RequestId != nil {
		return *x.RequestId
	}
	return ""
}

func (x *MoveFileRequest) GetFileId() string {
	if x != nil && x.FileId != nil {
		return *x.FileId
	}
	return ""
}

func (x *MoveFileRequest) GetNewName() string {
	if x != nil && x.NewName != nil {
		return *x.NewName
	}
	return ""
}

func (x *MoveFileRequest) GetNewLocation() string {
	if x != nil && x.NewLocation != nil {
		return *x.NewLocation
	}
	return ""
}

type MoveFileResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	FileId        *string                `protobuf:"bytes,1,opt,name=file_id,json=fileId" json:"file_id,omitempty"`
	NewFilename   *string                `protobuf:"bytes,2,opt,name=new_filename,json=newFilename" json:"new_filename,omitempty"`
	Success       *bool                  `protobuf:"varint,3,opt,name=success" json:"success,omitempty"`
	ErrorMessage  *string                `protobuf:"bytes,4,opt,name=error_message,json=errorMessage" json:"error_message,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *MoveFileResponse) Reset() {
	*x = MoveFileResponse{}
	mi := &file_file_v1_file_service_proto_msgTypes[14]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *MoveFileResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MoveFileResponse) ProtoMessage() {}

func (x *MoveFileResponse) ProtoReflect() protoreflect.Message {
	mi := &file_file_v1_file_service_proto_msgTypes[14]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use MoveFileResponse.ProtoReflect.Descriptor instead.
func (*MoveFileResponse) Descriptor() ([]byte, []int) {
	return file_file_v1_file_service_proto_rawDescGZIP(), []int{14}
}

func (x *MoveFileResponse) GetFileId() string {
	if x != nil && x.FileId != nil {
		return *x.FileId
	}
	return ""
}

func (x *MoveFileResponse) GetNewFilename() string {
	if x != nil && x.NewFilename != nil {
		return *x.NewFilename
	}
	return ""
}

func (x *MoveFileResponse) GetSuccess() bool {
	if x != nil && x.Success != nil {
		return *x.Success
	}
	return false
}

func (x *MoveFileResponse) GetErrorMessage() string {
	if x != nil && x.ErrorMessage != nil {
		return *x.ErrorMessage
	}
	return ""
}

type ListFilesRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	RequestId     *string                `protobuf:"bytes,1,opt,name=request_id,json=requestId" json:"request_id,omitempty"`
	UserId        *string                `protobuf:"bytes,2,opt,name=user_id,json=userId" json:"user_id,omitempty"`
	Path          *string                `protobuf:"bytes,3,opt,name=path" json:"path,omitempty"`
	Limit         *int32                 `protobuf:"varint,4,opt,name=limit" json:"limit,omitempty"`
	Offset        *int32                 `protobuf:"varint,5,opt,name=offset" json:"offset,omitempty"`
	Options       *ListOptions           `protobuf:"bytes,6,opt,name=options" json:"options,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ListFilesRequest) Reset() {
	*x = ListFilesRequest{}
	mi := &file_file_v1_file_service_proto_msgTypes[15]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ListFilesRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListFilesRequest) ProtoMessage() {}

func (x *ListFilesRequest) ProtoReflect() protoreflect.Message {
	mi := &file_file_v1_file_service_proto_msgTypes[15]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListFilesRequest.ProtoReflect.Descriptor instead.
func (*ListFilesRequest) Descriptor() ([]byte, []int) {
	return file_file_v1_file_service_proto_rawDescGZIP(), []int{15}
}

func (x *ListFilesRequest) GetRequestId() string {
	if x != nil && x.RequestId != nil {
		return *x.RequestId
	}
	return ""
}

func (x *ListFilesRequest) GetUserId() string {
	if x != nil && x.UserId != nil {
		return *x.UserId
	}
	return ""
}

func (x *ListFilesRequest) GetPath() string {
	if x != nil && x.Path != nil {
		return *x.Path
	}
	return ""
}

func (x *ListFilesRequest) GetLimit() int32 {
	if x != nil && x.Limit != nil {
		return *x.Limit
	}
	return 0
}

func (x *ListFilesRequest) GetOffset() int32 {
	if x != nil && x.Offset != nil {
		return *x.Offset
	}
	return 0
}

func (x *ListFilesRequest) GetOptions() *ListOptions {
	if x != nil {
		return x.Options
	}
	return nil
}

type ListOptions struct {
	state           protoimpl.MessageState `protogen:"open.v1"`
	IncludeMetadata *bool                  `protobuf:"varint,1,opt,name=include_metadata,json=includeMetadata" json:"include_metadata,omitempty"`
	SortBy          *string                `protobuf:"bytes,2,opt,name=sort_by,json=sortBy" json:"sort_by,omitempty"`
	SortOrder       *string                `protobuf:"bytes,3,opt,name=sort_order,json=sortOrder" json:"sort_order,omitempty"`
	FileTypes       []string               `protobuf:"bytes,4,rep,name=file_types,json=fileTypes" json:"file_types,omitempty"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *ListOptions) Reset() {
	*x = ListOptions{}
	mi := &file_file_v1_file_service_proto_msgTypes[16]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ListOptions) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListOptions) ProtoMessage() {}

func (x *ListOptions) ProtoReflect() protoreflect.Message {
	mi := &file_file_v1_file_service_proto_msgTypes[16]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListOptions.ProtoReflect.Descriptor instead.
func (*ListOptions) Descriptor() ([]byte, []int) {
	return file_file_v1_file_service_proto_rawDescGZIP(), []int{16}
}

func (x *ListOptions) GetIncludeMetadata() bool {
	if x != nil && x.IncludeMetadata != nil {
		return *x.IncludeMetadata
	}
	return false
}

func (x *ListOptions) GetSortBy() string {
	if x != nil && x.SortBy != nil {
		return *x.SortBy
	}
	return ""
}

func (x *ListOptions) GetSortOrder() string {
	if x != nil && x.SortOrder != nil {
		return *x.SortOrder
	}
	return ""
}

func (x *ListOptions) GetFileTypes() []string {
	if x != nil {
		return x.FileTypes
	}
	return nil
}

type ListFilesResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Files         []*FileEntry           `protobuf:"bytes,1,rep,name=files" json:"files,omitempty"`
	TotalCount    *int32                 `protobuf:"varint,2,opt,name=total_count,json=totalCount" json:"total_count,omitempty"`
	HasMore       *bool                  `protobuf:"varint,3,opt,name=has_more,json=hasMore" json:"has_more,omitempty"`
	Success       *bool                  `protobuf:"varint,4,opt,name=success" json:"success,omitempty"`
	ErrorMessage  *string                `protobuf:"bytes,5,opt,name=error_message,json=errorMessage" json:"error_message,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ListFilesResponse) Reset() {
	*x = ListFilesResponse{}
	mi := &file_file_v1_file_service_proto_msgTypes[17]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ListFilesResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListFilesResponse) ProtoMessage() {}

func (x *ListFilesResponse) ProtoReflect() protoreflect.Message {
	mi := &file_file_v1_file_service_proto_msgTypes[17]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListFilesResponse.ProtoReflect.Descriptor instead.
func (*ListFilesResponse) Descriptor() ([]byte, []int) {
	return file_file_v1_file_service_proto_rawDescGZIP(), []int{17}
}

func (x *ListFilesResponse) GetFiles() []*FileEntry {
	if x != nil {
		return x.Files
	}
	return nil
}

func (x *ListFilesResponse) GetTotalCount() int32 {
	if x != nil && x.TotalCount != nil {
		return *x.TotalCount
	}
	return 0
}

func (x *ListFilesResponse) GetHasMore() bool {
	if x != nil && x.HasMore != nil {
		return *x.HasMore
	}
	return false
}

func (x *ListFilesResponse) GetSuccess() bool {
	if x != nil && x.Success != nil {
		return *x.Success
	}
	return false
}

func (x *ListFilesResponse) GetErrorMessage() string {
	if x != nil && x.ErrorMessage != nil {
		return *x.ErrorMessage
	}
	return ""
}

type FileEntry struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	FileId        *string                `protobuf:"bytes,1,opt,name=file_id,json=fileId" json:"file_id,omitempty"`
	Filename      *string                `protobuf:"bytes,2,opt,name=filename" json:"filename,omitempty"`
	ContentType   *string                `protobuf:"bytes,3,opt,name=content_type,json=contentType" json:"content_type,omitempty"`
	Size          *int64                 `protobuf:"varint,4,opt,name=size" json:"size,omitempty"`
	CreatedAt     *string                `protobuf:"bytes,5,opt,name=created_at,json=createdAt" json:"created_at,omitempty"`
	ModifiedAt    *string                `protobuf:"bytes,6,opt,name=modified_at,json=modifiedAt" json:"modified_at,omitempty"`
	Metadata      map[string]string      `protobuf:"bytes,7,rep,name=metadata" json:"metadata,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *FileEntry) Reset() {
	*x = FileEntry{}
	mi := &file_file_v1_file_service_proto_msgTypes[18]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *FileEntry) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FileEntry) ProtoMessage() {}

func (x *FileEntry) ProtoReflect() protoreflect.Message {
	mi := &file_file_v1_file_service_proto_msgTypes[18]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FileEntry.ProtoReflect.Descriptor instead.
func (*FileEntry) Descriptor() ([]byte, []int) {
	return file_file_v1_file_service_proto_rawDescGZIP(), []int{18}
}

func (x *FileEntry) GetFileId() string {
	if x != nil && x.FileId != nil {
		return *x.FileId
	}
	return ""
}

func (x *FileEntry) GetFilename() string {
	if x != nil && x.Filename != nil {
		return *x.Filename
	}
	return ""
}

func (x *FileEntry) GetContentType() string {
	if x != nil && x.ContentType != nil {
		return *x.ContentType
	}
	return ""
}

func (x *FileEntry) GetSize() int64 {
	if x != nil && x.Size != nil {
		return *x.Size
	}
	return 0
}

func (x *FileEntry) GetCreatedAt() string {
	if x != nil && x.CreatedAt != nil {
		return *x.CreatedAt
	}
	return ""
}

func (x *FileEntry) GetModifiedAt() string {
	if x != nil && x.ModifiedAt != nil {
		return *x.ModifiedAt
	}
	return ""
}

func (x *FileEntry) GetMetadata() map[string]string {
	if x != nil {
		return x.Metadata
	}
	return nil
}

// Metadata Operations Messages
type UpdateFileMetadataRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	RequestId     *string                `protobuf:"bytes,1,opt,name=request_id,json=requestId" json:"request_id,omitempty"`
	FileId        *string                `protobuf:"bytes,2,opt,name=file_id,json=fileId" json:"file_id,omitempty"`
	Metadata      map[string]string      `protobuf:"bytes,3,rep,name=metadata" json:"metadata,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	ReplaceAll    *bool                  `protobuf:"varint,4,opt,name=replace_all,json=replaceAll" json:"replace_all,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *UpdateFileMetadataRequest) Reset() {
	*x = UpdateFileMetadataRequest{}
	mi := &file_file_v1_file_service_proto_msgTypes[19]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *UpdateFileMetadataRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UpdateFileMetadataRequest) ProtoMessage() {}

func (x *UpdateFileMetadataRequest) ProtoReflect() protoreflect.Message {
	mi := &file_file_v1_file_service_proto_msgTypes[19]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use UpdateFileMetadataRequest.ProtoReflect.Descriptor instead.
func (*UpdateFileMetadataRequest) Descriptor() ([]byte, []int) {
	return file_file_v1_file_service_proto_rawDescGZIP(), []int{19}
}

func (x *UpdateFileMetadataRequest) GetRequestId() string {
	if x != nil && x.RequestId != nil {
		return *x.RequestId
	}
	return ""
}

func (x *UpdateFileMetadataRequest) GetFileId() string {
	if x != nil && x.FileId != nil {
		return *x.FileId
	}
	return ""
}

func (x *UpdateFileMetadataRequest) GetMetadata() map[string]string {
	if x != nil {
		return x.Metadata
	}
	return nil
}

func (x *UpdateFileMetadataRequest) GetReplaceAll() bool {
	if x != nil && x.ReplaceAll != nil {
		return *x.ReplaceAll
	}
	return false
}

type UpdateFileMetadataResponse struct {
	state           protoimpl.MessageState `protogen:"open.v1"`
	FileId          *string                `protobuf:"bytes,1,opt,name=file_id,json=fileId" json:"file_id,omitempty"`
	UpdatedMetadata map[string]string      `protobuf:"bytes,2,rep,name=updated_metadata,json=updatedMetadata" json:"updated_metadata,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	Success         *bool                  `protobuf:"varint,3,opt,name=success" json:"success,omitempty"`
	ErrorMessage    *string                `protobuf:"bytes,4,opt,name=error_message,json=errorMessage" json:"error_message,omitempty"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *UpdateFileMetadataResponse) Reset() {
	*x = UpdateFileMetadataResponse{}
	mi := &file_file_v1_file_service_proto_msgTypes[20]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *UpdateFileMetadataResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UpdateFileMetadataResponse) ProtoMessage() {}

func (x *UpdateFileMetadataResponse) ProtoReflect() protoreflect.Message {
	mi := &file_file_v1_file_service_proto_msgTypes[20]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use UpdateFileMetadataResponse.ProtoReflect.Descriptor instead.
func (*UpdateFileMetadataResponse) Descriptor() ([]byte, []int) {
	return file_file_v1_file_service_proto_rawDescGZIP(), []int{20}
}

func (x *UpdateFileMetadataResponse) GetFileId() string {
	if x != nil && x.FileId != nil {
		return *x.FileId
	}
	return ""
}

func (x *UpdateFileMetadataResponse) GetUpdatedMetadata() map[string]string {
	if x != nil {
		return x.UpdatedMetadata
	}
	return nil
}

func (x *UpdateFileMetadataResponse) GetSuccess() bool {
	if x != nil && x.Success != nil {
		return *x.Success
	}
	return false
}

func (x *UpdateFileMetadataResponse) GetErrorMessage() string {
	if x != nil && x.ErrorMessage != nil {
		return *x.ErrorMessage
	}
	return ""
}

type SearchFilesRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	RequestId     *string                `protobuf:"bytes,1,opt,name=request_id,json=requestId" json:"request_id,omitempty"`
	UserId        *string                `protobuf:"bytes,2,opt,name=user_id,json=userId" json:"user_id,omitempty"`
	Query         *string                `protobuf:"bytes,3,opt,name=query" json:"query,omitempty"`
	Options       *SearchOptions         `protobuf:"bytes,4,opt,name=options" json:"options,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SearchFilesRequest) Reset() {
	*x = SearchFilesRequest{}
	mi := &file_file_v1_file_service_proto_msgTypes[21]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SearchFilesRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SearchFilesRequest) ProtoMessage() {}

func (x *SearchFilesRequest) ProtoReflect() protoreflect.Message {
	mi := &file_file_v1_file_service_proto_msgTypes[21]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SearchFilesRequest.ProtoReflect.Descriptor instead.
func (*SearchFilesRequest) Descriptor() ([]byte, []int) {
	return file_file_v1_file_service_proto_rawDescGZIP(), []int{21}
}

func (x *SearchFilesRequest) GetRequestId() string {
	if x != nil && x.RequestId != nil {
		return *x.RequestId
	}
	return ""
}

func (x *SearchFilesRequest) GetUserId() string {
	if x != nil && x.UserId != nil {
		return *x.UserId
	}
	return ""
}

func (x *SearchFilesRequest) GetQuery() string {
	if x != nil && x.Query != nil {
		return *x.Query
	}
	return ""
}

func (x *SearchFilesRequest) GetOptions() *SearchOptions {
	if x != nil {
		return x.Options
	}
	return nil
}

type SearchOptions struct {
	state           protoimpl.MessageState `protogen:"open.v1"`
	FileTypes       []string               `protobuf:"bytes,1,rep,name=file_types,json=fileTypes" json:"file_types,omitempty"`
	DateFrom        *string                `protobuf:"bytes,2,opt,name=date_from,json=dateFrom" json:"date_from,omitempty"`
	DateTo          *string                `protobuf:"bytes,3,opt,name=date_to,json=dateTo" json:"date_to,omitempty"`
	MinSize         *int64                 `protobuf:"varint,4,opt,name=min_size,json=minSize" json:"min_size,omitempty"`
	MaxSize         *int64                 `protobuf:"varint,5,opt,name=max_size,json=maxSize" json:"max_size,omitempty"`
	MetadataFilters map[string]string      `protobuf:"bytes,6,rep,name=metadata_filters,json=metadataFilters" json:"metadata_filters,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	Limit           *int32                 `protobuf:"varint,7,opt,name=limit" json:"limit,omitempty"`
	Offset          *int32                 `protobuf:"varint,8,opt,name=offset" json:"offset,omitempty"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *SearchOptions) Reset() {
	*x = SearchOptions{}
	mi := &file_file_v1_file_service_proto_msgTypes[22]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SearchOptions) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SearchOptions) ProtoMessage() {}

func (x *SearchOptions) ProtoReflect() protoreflect.Message {
	mi := &file_file_v1_file_service_proto_msgTypes[22]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SearchOptions.ProtoReflect.Descriptor instead.
func (*SearchOptions) Descriptor() ([]byte, []int) {
	return file_file_v1_file_service_proto_rawDescGZIP(), []int{22}
}

func (x *SearchOptions) GetFileTypes() []string {
	if x != nil {
		return x.FileTypes
	}
	return nil
}

func (x *SearchOptions) GetDateFrom() string {
	if x != nil && x.DateFrom != nil {
		return *x.DateFrom
	}
	return ""
}

func (x *SearchOptions) GetDateTo() string {
	if x != nil && x.DateTo != nil {
		return *x.DateTo
	}
	return ""
}

func (x *SearchOptions) GetMinSize() int64 {
	if x != nil && x.MinSize != nil {
		return *x.MinSize
	}
	return 0
}

func (x *SearchOptions) GetMaxSize() int64 {
	if x != nil && x.MaxSize != nil {
		return *x.MaxSize
	}
	return 0
}

func (x *SearchOptions) GetMetadataFilters() map[string]string {
	if x != nil {
		return x.MetadataFilters
	}
	return nil
}

func (x *SearchOptions) GetLimit() int32 {
	if x != nil && x.Limit != nil {
		return *x.Limit
	}
	return 0
}

func (x *SearchOptions) GetOffset() int32 {
	if x != nil && x.Offset != nil {
		return *x.Offset
	}
	return 0
}

type SearchFilesResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Files         []*FileEntry           `protobuf:"bytes,1,rep,name=files" json:"files,omitempty"`
	TotalCount    *int32                 `protobuf:"varint,2,opt,name=total_count,json=totalCount" json:"total_count,omitempty"`
	Success       *bool                  `protobuf:"varint,3,opt,name=success" json:"success,omitempty"`
	ErrorMessage  *string                `protobuf:"bytes,4,opt,name=error_message,json=errorMessage" json:"error_message,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SearchFilesResponse) Reset() {
	*x = SearchFilesResponse{}
	mi := &file_file_v1_file_service_proto_msgTypes[23]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SearchFilesResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SearchFilesResponse) ProtoMessage() {}

func (x *SearchFilesResponse) ProtoReflect() protoreflect.Message {
	mi := &file_file_v1_file_service_proto_msgTypes[23]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SearchFilesResponse.ProtoReflect.Descriptor instead.
func (*SearchFilesResponse) Descriptor() ([]byte, []int) {
	return file_file_v1_file_service_proto_rawDescGZIP(), []int{23}
}

func (x *SearchFilesResponse) GetFiles() []*FileEntry {
	if x != nil {
		return x.Files
	}
	return nil
}

func (x *SearchFilesResponse) GetTotalCount() int32 {
	if x != nil && x.TotalCount != nil {
		return *x.TotalCount
	}
	return 0
}

func (x *SearchFilesResponse) GetSuccess() bool {
	if x != nil && x.Success != nil {
		return *x.Success
	}
	return false
}

func (x *SearchFilesResponse) GetErrorMessage() string {
	if x != nil && x.ErrorMessage != nil {
		return *x.ErrorMessage
	}
	return ""
}

// Storage Management Messages
type GetStorageInfoRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	UserId        *string                `protobuf:"bytes,1,opt,name=user_id,json=userId" json:"user_id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetStorageInfoRequest) Reset() {
	*x = GetStorageInfoRequest{}
	mi := &file_file_v1_file_service_proto_msgTypes[24]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetStorageInfoRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetStorageInfoRequest) ProtoMessage() {}

func (x *GetStorageInfoRequest) ProtoReflect() protoreflect.Message {
	mi := &file_file_v1_file_service_proto_msgTypes[24]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetStorageInfoRequest.ProtoReflect.Descriptor instead.
func (*GetStorageInfoRequest) Descriptor() ([]byte, []int) {
	return file_file_v1_file_service_proto_rawDescGZIP(), []int{24}
}

func (x *GetStorageInfoRequest) GetUserId() string {
	if x != nil && x.UserId != nil {
		return *x.UserId
	}
	return ""
}

type GetStorageInfoResponse struct {
	state                protoimpl.MessageState `protogen:"open.v1"`
	TotalSpace           *int64                 `protobuf:"varint,1,opt,name=total_space,json=totalSpace" json:"total_space,omitempty"`
	UsedSpace            *int64                 `protobuf:"varint,2,opt,name=used_space,json=usedSpace" json:"used_space,omitempty"`
	AvailableSpace       *int64                 `protobuf:"varint,3,opt,name=available_space,json=availableSpace" json:"available_space,omitempty"`
	FileCount            *int32                 `protobuf:"varint,4,opt,name=file_count,json=fileCount" json:"file_count,omitempty"`
	FileTypeDistribution map[string]int64       `protobuf:"bytes,5,rep,name=file_type_distribution,json=fileTypeDistribution" json:"file_type_distribution,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"varint,2,opt,name=value"`
	Success              *bool                  `protobuf:"varint,6,opt,name=success" json:"success,omitempty"`
	ErrorMessage         *string                `protobuf:"bytes,7,opt,name=error_message,json=errorMessage" json:"error_message,omitempty"`
	unknownFields        protoimpl.UnknownFields
	sizeCache            protoimpl.SizeCache
}

func (x *GetStorageInfoResponse) Reset() {
	*x = GetStorageInfoResponse{}
	mi := &file_file_v1_file_service_proto_msgTypes[25]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetStorageInfoResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetStorageInfoResponse) ProtoMessage() {}

func (x *GetStorageInfoResponse) ProtoReflect() protoreflect.Message {
	mi := &file_file_v1_file_service_proto_msgTypes[25]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetStorageInfoResponse.ProtoReflect.Descriptor instead.
func (*GetStorageInfoResponse) Descriptor() ([]byte, []int) {
	return file_file_v1_file_service_proto_rawDescGZIP(), []int{25}
}

func (x *GetStorageInfoResponse) GetTotalSpace() int64 {
	if x != nil && x.TotalSpace != nil {
		return *x.TotalSpace
	}
	return 0
}

func (x *GetStorageInfoResponse) GetUsedSpace() int64 {
	if x != nil && x.UsedSpace != nil {
		return *x.UsedSpace
	}
	return 0
}

func (x *GetStorageInfoResponse) GetAvailableSpace() int64 {
	if x != nil && x.AvailableSpace != nil {
		return *x.AvailableSpace
	}
	return 0
}

func (x *GetStorageInfoResponse) GetFileCount() int32 {
	if x != nil && x.FileCount != nil {
		return *x.FileCount
	}
	return 0
}

func (x *GetStorageInfoResponse) GetFileTypeDistribution() map[string]int64 {
	if x != nil {
		return x.FileTypeDistribution
	}
	return nil
}

func (x *GetStorageInfoResponse) GetSuccess() bool {
	if x != nil && x.Success != nil {
		return *x.Success
	}
	return false
}

func (x *GetStorageInfoResponse) GetErrorMessage() string {
	if x != nil && x.ErrorMessage != nil {
		return *x.ErrorMessage
	}
	return ""
}

type CleanupFilesRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	UserId        *string                `protobuf:"bytes,1,opt,name=user_id,json=userId" json:"user_id,omitempty"`
	Options       *CleanupOptions        `protobuf:"bytes,2,opt,name=options" json:"options,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CleanupFilesRequest) Reset() {
	*x = CleanupFilesRequest{}
	mi := &file_file_v1_file_service_proto_msgTypes[26]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CleanupFilesRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CleanupFilesRequest) ProtoMessage() {}

func (x *CleanupFilesRequest) ProtoReflect() protoreflect.Message {
	mi := &file_file_v1_file_service_proto_msgTypes[26]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CleanupFilesRequest.ProtoReflect.Descriptor instead.
func (*CleanupFilesRequest) Descriptor() ([]byte, []int) {
	return file_file_v1_file_service_proto_rawDescGZIP(), []int{26}
}

func (x *CleanupFilesRequest) GetUserId() string {
	if x != nil && x.UserId != nil {
		return *x.UserId
	}
	return ""
}

func (x *CleanupFilesRequest) GetOptions() *CleanupOptions {
	if x != nil {
		return x.Options
	}
	return nil
}

type CleanupOptions struct {
	state           protoimpl.MessageState `protogen:"open.v1"`
	DaysOld         *int32                 `protobuf:"varint,1,opt,name=days_old,json=daysOld" json:"days_old,omitempty"`
	RemoveTemporary *bool                  `protobuf:"varint,2,opt,name=remove_temporary,json=removeTemporary" json:"remove_temporary,omitempty"`
	RemoveOrphaned  *bool                  `protobuf:"varint,3,opt,name=remove_orphaned,json=removeOrphaned" json:"remove_orphaned,omitempty"`
	FileTypes       []string               `protobuf:"bytes,4,rep,name=file_types,json=fileTypes" json:"file_types,omitempty"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *CleanupOptions) Reset() {
	*x = CleanupOptions{}
	mi := &file_file_v1_file_service_proto_msgTypes[27]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CleanupOptions) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CleanupOptions) ProtoMessage() {}

func (x *CleanupOptions) ProtoReflect() protoreflect.Message {
	mi := &file_file_v1_file_service_proto_msgTypes[27]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CleanupOptions.ProtoReflect.Descriptor instead.
func (*CleanupOptions) Descriptor() ([]byte, []int) {
	return file_file_v1_file_service_proto_rawDescGZIP(), []int{27}
}

func (x *CleanupOptions) GetDaysOld() int32 {
	if x != nil && x.DaysOld != nil {
		return *x.DaysOld
	}
	return 0
}

func (x *CleanupOptions) GetRemoveTemporary() bool {
	if x != nil && x.RemoveTemporary != nil {
		return *x.RemoveTemporary
	}
	return false
}

func (x *CleanupOptions) GetRemoveOrphaned() bool {
	if x != nil && x.RemoveOrphaned != nil {
		return *x.RemoveOrphaned
	}
	return false
}

func (x *CleanupOptions) GetFileTypes() []string {
	if x != nil {
		return x.FileTypes
	}
	return nil
}

type CleanupFilesResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	FilesDeleted  *int32                 `protobuf:"varint,1,opt,name=files_deleted,json=filesDeleted" json:"files_deleted,omitempty"`
	SpaceFreed    *int64                 `protobuf:"varint,2,opt,name=space_freed,json=spaceFreed" json:"space_freed,omitempty"`
	Success       *bool                  `protobuf:"varint,3,opt,name=success" json:"success,omitempty"`
	ErrorMessage  *string                `protobuf:"bytes,4,opt,name=error_message,json=errorMessage" json:"error_message,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CleanupFilesResponse) Reset() {
	*x = CleanupFilesResponse{}
	mi := &file_file_v1_file_service_proto_msgTypes[28]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CleanupFilesResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CleanupFilesResponse) ProtoMessage() {}

func (x *CleanupFilesResponse) ProtoReflect() protoreflect.Message {
	mi := &file_file_v1_file_service_proto_msgTypes[28]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CleanupFilesResponse.ProtoReflect.Descriptor instead.
func (*CleanupFilesResponse) Descriptor() ([]byte, []int) {
	return file_file_v1_file_service_proto_rawDescGZIP(), []int{28}
}

func (x *CleanupFilesResponse) GetFilesDeleted() int32 {
	if x != nil && x.FilesDeleted != nil {
		return *x.FilesDeleted
	}
	return 0
}

func (x *CleanupFilesResponse) GetSpaceFreed() int64 {
	if x != nil && x.SpaceFreed != nil {
		return *x.SpaceFreed
	}
	return 0
}

func (x *CleanupFilesResponse) GetSuccess() bool {
	if x != nil && x.Success != nil {
		return *x.Success
	}
	return false
}

func (x *CleanupFilesResponse) GetErrorMessage() string {
	if x != nil && x.ErrorMessage != nil {
		return *x.ErrorMessage
	}
	return ""
}

// Health Check Messages
type HealthCheckRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Service       *string                `protobuf:"bytes,1,opt,name=service" json:"service,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *HealthCheckRequest) Reset() {
	*x = HealthCheckRequest{}
	mi := &file_file_v1_file_service_proto_msgTypes[29]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *HealthCheckRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*HealthCheckRequest) ProtoMessage() {}

func (x *HealthCheckRequest) ProtoReflect() protoreflect.Message {
	mi := &file_file_v1_file_service_proto_msgTypes[29]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use HealthCheckRequest.ProtoReflect.Descriptor instead.
func (*HealthCheckRequest) Descriptor() ([]byte, []int) {
	return file_file_v1_file_service_proto_rawDescGZIP(), []int{29}
}

func (x *HealthCheckRequest) GetService() string {
	if x != nil && x.Service != nil {
		return *x.Service
	}
	return ""
}

type HealthCheckResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Status        *string                `protobuf:"bytes,1,opt,name=status" json:"status,omitempty"`
	Message       *string                `protobuf:"bytes,2,opt,name=message" json:"message,omitempty"`
	StorageHealth *StorageHealth         `protobuf:"bytes,3,opt,name=storage_health,json=storageHealth" json:"storage_health,omitempty"`
	Success       *bool                  `protobuf:"varint,4,opt,name=success" json:"success,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *HealthCheckResponse) Reset() {
	*x = HealthCheckResponse{}
	mi := &file_file_v1_file_service_proto_msgTypes[30]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *HealthCheckResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*HealthCheckResponse) ProtoMessage() {}

func (x *HealthCheckResponse) ProtoReflect() protoreflect.Message {
	mi := &file_file_v1_file_service_proto_msgTypes[30]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use HealthCheckResponse.ProtoReflect.Descriptor instead.
func (*HealthCheckResponse) Descriptor() ([]byte, []int) {
	return file_file_v1_file_service_proto_rawDescGZIP(), []int{30}
}

func (x *HealthCheckResponse) GetStatus() string {
	if x != nil && x.Status != nil {
		return *x.Status
	}
	return ""
}

func (x *HealthCheckResponse) GetMessage() string {
	if x != nil && x.Message != nil {
		return *x.Message
	}
	return ""
}

func (x *HealthCheckResponse) GetStorageHealth() *StorageHealth {
	if x != nil {
		return x.StorageHealth
	}
	return nil
}

func (x *HealthCheckResponse) GetSuccess() bool {
	if x != nil && x.Success != nil {
		return *x.Success
	}
	return false
}

type StorageHealth struct {
	state           protoimpl.MessageState `protogen:"open.v1"`
	TotalSpace      *int64                 `protobuf:"varint,1,opt,name=total_space,json=totalSpace" json:"total_space,omitempty"`
	AvailableSpace  *int64                 `protobuf:"varint,2,opt,name=available_space,json=availableSpace" json:"available_space,omitempty"`
	UsagePercentage *float32               `protobuf:"fixed32,3,opt,name=usage_percentage,json=usagePercentage" json:"usage_percentage,omitempty"`
	Healthy         *bool                  `protobuf:"varint,4,opt,name=healthy" json:"healthy,omitempty"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *StorageHealth) Reset() {
	*x = StorageHealth{}
	mi := &file_file_v1_file_service_proto_msgTypes[31]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StorageHealth) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StorageHealth) ProtoMessage() {}

func (x *StorageHealth) ProtoReflect() protoreflect.Message {
	mi := &file_file_v1_file_service_proto_msgTypes[31]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StorageHealth.ProtoReflect.Descriptor instead.
func (*StorageHealth) Descriptor() ([]byte, []int) {
	return file_file_v1_file_service_proto_rawDescGZIP(), []int{31}
}

func (x *StorageHealth) GetTotalSpace() int64 {
	if x != nil && x.TotalSpace != nil {
		return *x.TotalSpace
	}
	return 0
}

func (x *StorageHealth) GetAvailableSpace() int64 {
	if x != nil && x.AvailableSpace != nil {
		return *x.AvailableSpace
	}
	return 0
}

func (x *StorageHealth) GetUsagePercentage() float32 {
	if x != nil && x.UsagePercentage != nil {
		return *x.UsagePercentage
	}
	return 0
}

func (x *StorageHealth) GetHealthy() bool {
	if x != nil && x.Healthy != nil {
		return *x.Healthy
	}
	return false
}

var File_file_v1_file_service_proto protoreflect.FileDescriptor

const file_file_v1_file_service_proto_rawDesc = "" +
	"\n" +
	"\x1afile/v1/file_service.proto\x12\x18subtitle_manager.file.v1\"\xa1\x01\n" +
	"\x11UploadFileRequest\x12D\n" +
	"\bmetadata\x18\x01 \x01(\v2&.subtitle_manager.file.v1.FileMetadataH\x00R\bmetadata\x12;\n" +
	"\x05chunk\x18\x02 \x01(\v2#.subtitle_manager.file.v1.FileChunkH\x00R\x05chunkB\t\n" +
	"\arequest\"\xad\x02\n" +
	"\fFileMetadata\x12\x1a\n" +
	"\bfilename\x18\x01 \x01(\tR\bfilename\x12!\n" +
	"\fcontent_type\x18\x02 \x01(\tR\vcontentType\x12\x1d\n" +
	"\n" +
	"total_size\x18\x03 \x01(\x03R\ttotalSize\x12\x17\n" +
	"\auser_id\x18\x04 \x01(\tR\x06userId\x12c\n" +
	"\x0fcustom_metadata\x18\x05 \x03(\v2:.subtitle_manager.file.v1.FileMetadata.CustomMetadataEntryR\x0ecustomMetadata\x1aA\n" +
	"\x13CustomMetadataEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\"P\n" +
	"\tFileChunk\x12\x12\n" +
	"\x04data\x18\x01 \x01(\fR\x04data\x12\x16\n" +
	"\x06offset\x18\x02 \x01(\x03R\x06offset\x12\x17\n" +
	"\ais_last\x18\x03 \x01(\bR\x06isLast\"\x9c\x01\n" +
	"\x12UploadFileResponse\x12\x17\n" +
	"\afile_id\x18\x01 \x01(\tR\x06fileId\x12\x1a\n" +
	"\bfilename\x18\x02 \x01(\tR\bfilename\x12\x12\n" +
	"\x04size\x18\x03 \x01(\x03R\x04size\x12\x18\n" +
	"\asuccess\x18\x04 \x01(\bR\asuccess\x12#\n" +
	"\rerror_message\x18\x05 \x01(\tR\ferrorMessage\"}\n" +
	"\x13DownloadFileRequest\x12\x1d\n" +
	"\n" +
	"request_id\x18\x01 \x01(\tR\trequestId\x12\x17\n" +
	"\afile_id\x18\x02 \x01(\tR\x06fileId\x12\x16\n" +
	"\x06offset\x18\x03 \x01(\x03R\x06offset\x12\x16\n" +
	"\x06length\x18\x04 \x01(\x03R\x06length\"\xa2\x01\n" +
	"\x14DownloadFileResponse\x12A\n" +
	"\tfile_info\x18\x01 \x01(\v2\".subtitle_manager.file.v1.FileInfoH\x00R\bfileInfo\x12;\n" +
	"\x05chunk\x18\x02 \x01(\v2#.subtitle_manager.file.v1.FileChunkH\x00R\x05chunkB\n" +
	"\n" +
	"\bresponse\"\xf3\x01\n" +
	"\bFileInfo\x12\x1a\n" +
	"\bfilename\x18\x01 \x01(\tR\bfilename\x12!\n" +
	"\fcontent_type\x18\x02 \x01(\tR\vcontentType\x12\x1d\n" +
	"\n" +
	"total_size\x18\x03 \x01(\x03R\ttotalSize\x12L\n" +
	"\bmetadata\x18\x04 \x03(\v20.subtitle_manager.file.v1.FileInfo.MetadataEntryR\bmetadata\x1a;\n" +
	"\rMetadataEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\"i\n" +
	"\x11DeleteFileRequest\x12\x1d\n" +
	"\n" +
	"request_id\x18\x01 \x01(\tR\trequestId\x12\x17\n" +
	"\afile_id\x18\x02 \x01(\tR\x06fileId\x12\x1c\n" +
	"\tpermanent\x18\x03 \x01(\bR\tpermanent\"\x86\x01\n" +
	"\x12DeleteFileResponse\x12\x17\n" +
	"\afile_id\x18\x01 \x01(\tR\x06fileId\x12\x18\n" +
	"\adeleted\x18\x02 \x01(\bR\adeleted\x12\x18\n" +
	"\asuccess\x18\x03 \x01(\bR\asuccess\x12#\n" +
	"\rerror_message\x18\x04 \x01(\tR\ferrorMessage\"w\n" +
	"\x12GetFileInfoRequest\x12\x1d\n" +
	"\n" +
	"request_id\x18\x01 \x01(\tR\trequestId\x12\x17\n" +
	"\afile_id\x18\x02 \x01(\tR\x06fileId\x12)\n" +
	"\x10include_metadata\x18\x03 \x01(\bR\x0fincludeMetadata\"\xaf\x03\n" +
	"\x13GetFileInfoResponse\x12\x17\n" +
	"\afile_id\x18\x01 \x01(\tR\x06fileId\x12\x1a\n" +
	"\bfilename\x18\x02 \x01(\tR\bfilename\x12!\n" +
	"\fcontent_type\x18\x03 \x01(\tR\vcontentType\x12\x12\n" +
	"\x04size\x18\x04 \x01(\x03R\x04size\x12\x1d\n" +
	"\n" +
	"created_at\x18\x05 \x01(\tR\tcreatedAt\x12\x1f\n" +
	"\vmodified_at\x18\x06 \x01(\tR\n" +
	"modifiedAt\x12\x17\n" +
	"\auser_id\x18\a \x01(\tR\x06userId\x12W\n" +
	"\bmetadata\x18\b \x03(\v2;.subtitle_manager.file.v1.GetFileInfoResponse.MetadataEntryR\bmetadata\x12\x18\n" +
	"\asuccess\x18\t \x01(\bR\asuccess\x12#\n" +
	"\rerror_message\x18\n" +
	" \x01(\tR\ferrorMessage\x1a;\n" +
	"\rMetadataEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\"\x9a\x01\n" +
	"\x0fCopyFileRequest\x12\x1d\n" +
	"\n" +
	"request_id\x18\x01 \x01(\tR\trequestId\x12$\n" +
	"\x0esource_file_id\x18\x02 \x01(\tR\fsourceFileId\x12)\n" +
	"\x10destination_name\x18\x03 \x01(\tR\x0fdestinationName\x12\x17\n" +
	"\auser_id\x18\x04 \x01(\tR\x06userId\"\x8d\x01\n" +
	"\x10CopyFileResponse\x12\x1e\n" +
	"\vnew_file_id\x18\x01 \x01(\tR\tnewFileId\x12\x1a\n" +
	"\bfilename\x18\x02 \x01(\tR\bfilename\x12\x18\n" +
	"\asuccess\x18\x03 \x01(\bR\asuccess\x12#\n" +
	"\rerror_message\x18\x04 \x01(\tR\ferrorMessage\"\x87\x01\n" +
	"\x0fMoveFileRequest\x12\x1d\n" +
	"\n" +
	"request_id\x18\x01 \x01(\tR\trequestId\x12\x17\n" +
	"\afile_id\x18\x02 \x01(\tR\x06fileId\x12\x19\n" +
	"\bnew_name\x18\x03 \x01(\tR\anewName\x12!\n" +
	"\fnew_location\x18\x04 \x01(\tR\vnewLocation\"\x8d\x01\n" +
	"\x10MoveFileResponse\x12\x17\n" +
	"\afile_id\x18\x01 \x01(\tR\x06fileId\x12!\n" +
	"\fnew_filename\x18\x02 \x01(\tR\vnewFilename\x12\x18\n" +
	"\asuccess\x18\x03 \x01(\bR\asuccess\x12#\n" +
	"\rerror_message\x18\x04 \x01(\tR\ferrorMessage\"\xcd\x01\n" +
	"\x10ListFilesRequest\x12\x1d\n" +
	"\n" +
	"request_id\x18\x01 \x01(\tR\trequestId\x12\x17\n" +
	"\auser_id\x18\x02 \x01(\tR\x06userId\x12\x12\n" +
	"\x04path\x18\x03 \x01(\tR\x04path\x12\x14\n" +
	"\x05limit\x18\x04 \x01(\x05R\x05limit\x12\x16\n" +
	"\x06offset\x18\x05 \x01(\x05R\x06offset\x12?\n" +
	"\aoptions\x18\x06 \x01(\v2%.subtitle_manager.file.v1.ListOptionsR\aoptions\"\x8f\x01\n" +
	"\vListOptions\x12)\n" +
	"\x10include_metadata\x18\x01 \x01(\bR\x0fincludeMetadata\x12\x17\n" +
	"\asort_by\x18\x02 \x01(\tR\x06sortBy\x12\x1d\n" +
	"\n" +
	"sort_order\x18\x03 \x01(\tR\tsortOrder\x12\x1d\n" +
	"\n" +
	"file_types\x18\x04 \x03(\tR\tfileTypes\"\xc9\x01\n" +
	"\x11ListFilesResponse\x129\n" +
	"\x05files\x18\x01 \x03(\v2#.subtitle_manager.file.v1.FileEntryR\x05files\x12\x1f\n" +
	"\vtotal_count\x18\x02 \x01(\x05R\n" +
	"totalCount\x12\x19\n" +
	"\bhas_more\x18\x03 \x01(\bR\ahasMore\x12\x18\n" +
	"\asuccess\x18\x04 \x01(\bR\asuccess\x12#\n" +
	"\rerror_message\x18\x05 \x01(\tR\ferrorMessage\"\xc3\x02\n" +
	"\tFileEntry\x12\x17\n" +
	"\afile_id\x18\x01 \x01(\tR\x06fileId\x12\x1a\n" +
	"\bfilename\x18\x02 \x01(\tR\bfilename\x12!\n" +
	"\fcontent_type\x18\x03 \x01(\tR\vcontentType\x12\x12\n" +
	"\x04size\x18\x04 \x01(\x03R\x04size\x12\x1d\n" +
	"\n" +
	"created_at\x18\x05 \x01(\tR\tcreatedAt\x12\x1f\n" +
	"\vmodified_at\x18\x06 \x01(\tR\n" +
	"modifiedAt\x12M\n" +
	"\bmetadata\x18\a \x03(\v21.subtitle_manager.file.v1.FileEntry.MetadataEntryR\bmetadata\x1a;\n" +
	"\rMetadataEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\"\x90\x02\n" +
	"\x19UpdateFileMetadataRequest\x12\x1d\n" +
	"\n" +
	"request_id\x18\x01 \x01(\tR\trequestId\x12\x17\n" +
	"\afile_id\x18\x02 \x01(\tR\x06fileId\x12]\n" +
	"\bmetadata\x18\x03 \x03(\v2A.subtitle_manager.file.v1.UpdateFileMetadataRequest.MetadataEntryR\bmetadata\x12\x1f\n" +
	"\vreplace_all\x18\x04 \x01(\bR\n" +
	"replaceAll\x1a;\n" +
	"\rMetadataEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\"\xae\x02\n" +
	"\x1aUpdateFileMetadataResponse\x12\x17\n" +
	"\afile_id\x18\x01 \x01(\tR\x06fileId\x12t\n" +
	"\x10updated_metadata\x18\x02 \x03(\v2I.subtitle_manager.file.v1.UpdateFileMetadataResponse.UpdatedMetadataEntryR\x0fupdatedMetadata\x12\x18\n" +
	"\asuccess\x18\x03 \x01(\bR\asuccess\x12#\n" +
	"\rerror_message\x18\x04 \x01(\tR\ferrorMessage\x1aB\n" +
	"\x14UpdatedMetadataEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\"\xa5\x01\n" +
	"\x12SearchFilesRequest\x12\x1d\n" +
	"\n" +
	"request_id\x18\x01 \x01(\tR\trequestId\x12\x17\n" +
	"\auser_id\x18\x02 \x01(\tR\x06userId\x12\x14\n" +
	"\x05query\x18\x03 \x01(\tR\x05query\x12A\n" +
	"\aoptions\x18\x04 \x01(\v2'.subtitle_manager.file.v1.SearchOptionsR\aoptions\"\xf5\x02\n" +
	"\rSearchOptions\x12\x1d\n" +
	"\n" +
	"file_types\x18\x01 \x03(\tR\tfileTypes\x12\x1b\n" +
	"\tdate_from\x18\x02 \x01(\tR\bdateFrom\x12\x17\n" +
	"\adate_to\x18\x03 \x01(\tR\x06dateTo\x12\x19\n" +
	"\bmin_size\x18\x04 \x01(\x03R\aminSize\x12\x19\n" +
	"\bmax_size\x18\x05 \x01(\x03R\amaxSize\x12g\n" +
	"\x10metadata_filters\x18\x06 \x03(\v2<.subtitle_manager.file.v1.SearchOptions.MetadataFiltersEntryR\x0fmetadataFilters\x12\x14\n" +
	"\x05limit\x18\a \x01(\x05R\x05limit\x12\x16\n" +
	"\x06offset\x18\b \x01(\x05R\x06offset\x1aB\n" +
	"\x14MetadataFiltersEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\"\xb0\x01\n" +
	"\x13SearchFilesResponse\x129\n" +
	"\x05files\x18\x01 \x03(\v2#.subtitle_manager.file.v1.FileEntryR\x05files\x12\x1f\n" +
	"\vtotal_count\x18\x02 \x01(\x05R\n" +
	"totalCount\x12\x18\n" +
	"\asuccess\x18\x03 \x01(\bR\asuccess\x12#\n" +
	"\rerror_message\x18\x04 \x01(\tR\ferrorMessage\"0\n" +
	"\x15GetStorageInfoRequest\x12\x17\n" +
	"\auser_id\x18\x01 \x01(\tR\x06userId\"\xab\x03\n" +
	"\x16GetStorageInfoResponse\x12\x1f\n" +
	"\vtotal_space\x18\x01 \x01(\x03R\n" +
	"totalSpace\x12\x1d\n" +
	"\n" +
	"used_space\x18\x02 \x01(\x03R\tusedSpace\x12'\n" +
	"\x0favailable_space\x18\x03 \x01(\x03R\x0eavailableSpace\x12\x1d\n" +
	"\n" +
	"file_count\x18\x04 \x01(\x05R\tfileCount\x12\x80\x01\n" +
	"\x16file_type_distribution\x18\x05 \x03(\v2J.subtitle_manager.file.v1.GetStorageInfoResponse.FileTypeDistributionEntryR\x14fileTypeDistribution\x12\x18\n" +
	"\asuccess\x18\x06 \x01(\bR\asuccess\x12#\n" +
	"\rerror_message\x18\a \x01(\tR\ferrorMessage\x1aG\n" +
	"\x19FileTypeDistributionEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\x03R\x05value:\x028\x01\"r\n" +
	"\x13CleanupFilesRequest\x12\x17\n" +
	"\auser_id\x18\x01 \x01(\tR\x06userId\x12B\n" +
	"\aoptions\x18\x02 \x01(\v2(.subtitle_manager.file.v1.CleanupOptionsR\aoptions\"\x9e\x01\n" +
	"\x0eCleanupOptions\x12\x19\n" +
	"\bdays_old\x18\x01 \x01(\x05R\adaysOld\x12)\n" +
	"\x10remove_temporary\x18\x02 \x01(\bR\x0fremoveTemporary\x12'\n" +
	"\x0fremove_orphaned\x18\x03 \x01(\bR\x0eremoveOrphaned\x12\x1d\n" +
	"\n" +
	"file_types\x18\x04 \x03(\tR\tfileTypes\"\x9b\x01\n" +
	"\x14CleanupFilesResponse\x12#\n" +
	"\rfiles_deleted\x18\x01 \x01(\x05R\ffilesDeleted\x12\x1f\n" +
	"\vspace_freed\x18\x02 \x01(\x03R\n" +
	"spaceFreed\x12\x18\n" +
	"\asuccess\x18\x03 \x01(\bR\asuccess\x12#\n" +
	"\rerror_message\x18\x04 \x01(\tR\ferrorMessage\".\n" +
	"\x12HealthCheckRequest\x12\x18\n" +
	"\aservice\x18\x01 \x01(\tR\aservice\"\xb1\x01\n" +
	"\x13HealthCheckResponse\x12\x16\n" +
	"\x06status\x18\x01 \x01(\tR\x06status\x12\x18\n" +
	"\amessage\x18\x02 \x01(\tR\amessage\x12N\n" +
	"\x0estorage_health\x18\x03 \x01(\v2'.subtitle_manager.file.v1.StorageHealthR\rstorageHealth\x12\x18\n" +
	"\asuccess\x18\x04 \x01(\bR\asuccess\"\x9e\x01\n" +
	"\rStorageHealth\x12\x1f\n" +
	"\vtotal_space\x18\x01 \x01(\x03R\n" +
	"totalSpace\x12'\n" +
	"\x0favailable_space\x18\x02 \x01(\x03R\x0eavailableSpace\x12)\n" +
	"\x10usage_percentage\x18\x03 \x01(\x02R\x0fusagePercentage\x12\x18\n" +
	"\ahealthy\x18\x04 \x01(\bR\ahealthy2\xa7\n" +
	"\n" +
	"\vFileService\x12i\n" +
	"\n" +
	"UploadFile\x12+.subtitle_manager.file.v1.UploadFileRequest\x1a,.subtitle_manager.file.v1.UploadFileResponse(\x01\x12o\n" +
	"\fDownloadFile\x12-.subtitle_manager.file.v1.DownloadFileRequest\x1a..subtitle_manager.file.v1.DownloadFileResponse0\x01\x12g\n" +
	"\n" +
	"DeleteFile\x12+.subtitle_manager.file.v1.DeleteFileRequest\x1a,.subtitle_manager.file.v1.DeleteFileResponse\x12j\n" +
	"\vGetFileInfo\x12,.subtitle_manager.file.v1.GetFileInfoRequest\x1a-.subtitle_manager.file.v1.GetFileInfoResponse\x12a\n" +
	"\bCopyFile\x12).subtitle_manager.file.v1.CopyFileRequest\x1a*.subtitle_manager.file.v1.CopyFileResponse\x12a\n" +
	"\bMoveFile\x12).subtitle_manager.file.v1.MoveFileRequest\x1a*.subtitle_manager.file.v1.MoveFileResponse\x12d\n" +
	"\tListFiles\x12*.subtitle_manager.file.v1.ListFilesRequest\x1a+.subtitle_manager.file.v1.ListFilesResponse\x12\x7f\n" +
	"\x12UpdateFileMetadata\x123.subtitle_manager.file.v1.UpdateFileMetadataRequest\x1a4.subtitle_manager.file.v1.UpdateFileMetadataResponse\x12j\n" +
	"\vSearchFiles\x12,.subtitle_manager.file.v1.SearchFilesRequest\x1a-.subtitle_manager.file.v1.SearchFilesResponse\x12s\n" +
	"\x0eGetStorageInfo\x12/.subtitle_manager.file.v1.GetStorageInfoRequest\x1a0.subtitle_manager.file.v1.GetStorageInfoResponse\x12m\n" +
	"\fCleanupFiles\x12-.subtitle_manager.file.v1.CleanupFilesRequest\x1a..subtitle_manager.file.v1.CleanupFilesResponse\x12j\n" +
	"\vHealthCheck\x12,.subtitle_manager.file.v1.HealthCheckRequest\x1a-.subtitle_manager.file.v1.HealthCheckResponseB0Z.github.com/jdfalk/subtitle-manager/pkg/file/v1b\beditionsp\xe8\a"

var (
	file_file_v1_file_service_proto_rawDescOnce sync.Once
	file_file_v1_file_service_proto_rawDescData []byte
)

func file_file_v1_file_service_proto_rawDescGZIP() []byte {
	file_file_v1_file_service_proto_rawDescOnce.Do(func() {
		file_file_v1_file_service_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_file_v1_file_service_proto_rawDesc), len(file_file_v1_file_service_proto_rawDesc)))
	})
	return file_file_v1_file_service_proto_rawDescData
}

var file_file_v1_file_service_proto_msgTypes = make([]protoimpl.MessageInfo, 40)
var file_file_v1_file_service_proto_goTypes = []any{
	(*UploadFileRequest)(nil),          // 0: subtitle_manager.file.v1.UploadFileRequest
	(*FileMetadata)(nil),               // 1: subtitle_manager.file.v1.FileMetadata
	(*FileChunk)(nil),                  // 2: subtitle_manager.file.v1.FileChunk
	(*UploadFileResponse)(nil),         // 3: subtitle_manager.file.v1.UploadFileResponse
	(*DownloadFileRequest)(nil),        // 4: subtitle_manager.file.v1.DownloadFileRequest
	(*DownloadFileResponse)(nil),       // 5: subtitle_manager.file.v1.DownloadFileResponse
	(*FileInfo)(nil),                   // 6: subtitle_manager.file.v1.FileInfo
	(*DeleteFileRequest)(nil),          // 7: subtitle_manager.file.v1.DeleteFileRequest
	(*DeleteFileResponse)(nil),         // 8: subtitle_manager.file.v1.DeleteFileResponse
	(*GetFileInfoRequest)(nil),         // 9: subtitle_manager.file.v1.GetFileInfoRequest
	(*GetFileInfoResponse)(nil),        // 10: subtitle_manager.file.v1.GetFileInfoResponse
	(*CopyFileRequest)(nil),            // 11: subtitle_manager.file.v1.CopyFileRequest
	(*CopyFileResponse)(nil),           // 12: subtitle_manager.file.v1.CopyFileResponse
	(*MoveFileRequest)(nil),            // 13: subtitle_manager.file.v1.MoveFileRequest
	(*MoveFileResponse)(nil),           // 14: subtitle_manager.file.v1.MoveFileResponse
	(*ListFilesRequest)(nil),           // 15: subtitle_manager.file.v1.ListFilesRequest
	(*ListOptions)(nil),                // 16: subtitle_manager.file.v1.ListOptions
	(*ListFilesResponse)(nil),          // 17: subtitle_manager.file.v1.ListFilesResponse
	(*FileEntry)(nil),                  // 18: subtitle_manager.file.v1.FileEntry
	(*UpdateFileMetadataRequest)(nil),  // 19: subtitle_manager.file.v1.UpdateFileMetadataRequest
	(*UpdateFileMetadataResponse)(nil), // 20: subtitle_manager.file.v1.UpdateFileMetadataResponse
	(*SearchFilesRequest)(nil),         // 21: subtitle_manager.file.v1.SearchFilesRequest
	(*SearchOptions)(nil),              // 22: subtitle_manager.file.v1.SearchOptions
	(*SearchFilesResponse)(nil),        // 23: subtitle_manager.file.v1.SearchFilesResponse
	(*GetStorageInfoRequest)(nil),      // 24: subtitle_manager.file.v1.GetStorageInfoRequest
	(*GetStorageInfoResponse)(nil),     // 25: subtitle_manager.file.v1.GetStorageInfoResponse
	(*CleanupFilesRequest)(nil),        // 26: subtitle_manager.file.v1.CleanupFilesRequest
	(*CleanupOptions)(nil),             // 27: subtitle_manager.file.v1.CleanupOptions
	(*CleanupFilesResponse)(nil),       // 28: subtitle_manager.file.v1.CleanupFilesResponse
	(*HealthCheckRequest)(nil),         // 29: subtitle_manager.file.v1.HealthCheckRequest
	(*HealthCheckResponse)(nil),        // 30: subtitle_manager.file.v1.HealthCheckResponse
	(*StorageHealth)(nil),              // 31: subtitle_manager.file.v1.StorageHealth
	nil,                                // 32: subtitle_manager.file.v1.FileMetadata.CustomMetadataEntry
	nil,                                // 33: subtitle_manager.file.v1.FileInfo.MetadataEntry
	nil,                                // 34: subtitle_manager.file.v1.GetFileInfoResponse.MetadataEntry
	nil,                                // 35: subtitle_manager.file.v1.FileEntry.MetadataEntry
	nil,                                // 36: subtitle_manager.file.v1.UpdateFileMetadataRequest.MetadataEntry
	nil,                                // 37: subtitle_manager.file.v1.UpdateFileMetadataResponse.UpdatedMetadataEntry
	nil,                                // 38: subtitle_manager.file.v1.SearchOptions.MetadataFiltersEntry
	nil,                                // 39: subtitle_manager.file.v1.GetStorageInfoResponse.FileTypeDistributionEntry
}
var file_file_v1_file_service_proto_depIdxs = []int32{
	1,  // 0: subtitle_manager.file.v1.UploadFileRequest.metadata:type_name -> subtitle_manager.file.v1.FileMetadata
	2,  // 1: subtitle_manager.file.v1.UploadFileRequest.chunk:type_name -> subtitle_manager.file.v1.FileChunk
	32, // 2: subtitle_manager.file.v1.FileMetadata.custom_metadata:type_name -> subtitle_manager.file.v1.FileMetadata.CustomMetadataEntry
	6,  // 3: subtitle_manager.file.v1.DownloadFileResponse.file_info:type_name -> subtitle_manager.file.v1.FileInfo
	2,  // 4: subtitle_manager.file.v1.DownloadFileResponse.chunk:type_name -> subtitle_manager.file.v1.FileChunk
	33, // 5: subtitle_manager.file.v1.FileInfo.metadata:type_name -> subtitle_manager.file.v1.FileInfo.MetadataEntry
	34, // 6: subtitle_manager.file.v1.GetFileInfoResponse.metadata:type_name -> subtitle_manager.file.v1.GetFileInfoResponse.MetadataEntry
	16, // 7: subtitle_manager.file.v1.ListFilesRequest.options:type_name -> subtitle_manager.file.v1.ListOptions
	18, // 8: subtitle_manager.file.v1.ListFilesResponse.files:type_name -> subtitle_manager.file.v1.FileEntry
	35, // 9: subtitle_manager.file.v1.FileEntry.metadata:type_name -> subtitle_manager.file.v1.FileEntry.MetadataEntry
	36, // 10: subtitle_manager.file.v1.UpdateFileMetadataRequest.metadata:type_name -> subtitle_manager.file.v1.UpdateFileMetadataRequest.MetadataEntry
	37, // 11: subtitle_manager.file.v1.UpdateFileMetadataResponse.updated_metadata:type_name -> subtitle_manager.file.v1.UpdateFileMetadataResponse.UpdatedMetadataEntry
	22, // 12: subtitle_manager.file.v1.SearchFilesRequest.options:type_name -> subtitle_manager.file.v1.SearchOptions
	38, // 13: subtitle_manager.file.v1.SearchOptions.metadata_filters:type_name -> subtitle_manager.file.v1.SearchOptions.MetadataFiltersEntry
	18, // 14: subtitle_manager.file.v1.SearchFilesResponse.files:type_name -> subtitle_manager.file.v1.FileEntry
	39, // 15: subtitle_manager.file.v1.GetStorageInfoResponse.file_type_distribution:type_name -> subtitle_manager.file.v1.GetStorageInfoResponse.FileTypeDistributionEntry
	27, // 16: subtitle_manager.file.v1.CleanupFilesRequest.options:type_name -> subtitle_manager.file.v1.CleanupOptions
	31, // 17: subtitle_manager.file.v1.HealthCheckResponse.storage_health:type_name -> subtitle_manager.file.v1.StorageHealth
	0,  // 18: subtitle_manager.file.v1.FileService.UploadFile:input_type -> subtitle_manager.file.v1.UploadFileRequest
	4,  // 19: subtitle_manager.file.v1.FileService.DownloadFile:input_type -> subtitle_manager.file.v1.DownloadFileRequest
	7,  // 20: subtitle_manager.file.v1.FileService.DeleteFile:input_type -> subtitle_manager.file.v1.DeleteFileRequest
	9,  // 21: subtitle_manager.file.v1.FileService.GetFileInfo:input_type -> subtitle_manager.file.v1.GetFileInfoRequest
	11, // 22: subtitle_manager.file.v1.FileService.CopyFile:input_type -> subtitle_manager.file.v1.CopyFileRequest
	13, // 23: subtitle_manager.file.v1.FileService.MoveFile:input_type -> subtitle_manager.file.v1.MoveFileRequest
	15, // 24: subtitle_manager.file.v1.FileService.ListFiles:input_type -> subtitle_manager.file.v1.ListFilesRequest
	19, // 25: subtitle_manager.file.v1.FileService.UpdateFileMetadata:input_type -> subtitle_manager.file.v1.UpdateFileMetadataRequest
	21, // 26: subtitle_manager.file.v1.FileService.SearchFiles:input_type -> subtitle_manager.file.v1.SearchFilesRequest
	24, // 27: subtitle_manager.file.v1.FileService.GetStorageInfo:input_type -> subtitle_manager.file.v1.GetStorageInfoRequest
	26, // 28: subtitle_manager.file.v1.FileService.CleanupFiles:input_type -> subtitle_manager.file.v1.CleanupFilesRequest
	29, // 29: subtitle_manager.file.v1.FileService.HealthCheck:input_type -> subtitle_manager.file.v1.HealthCheckRequest
	3,  // 30: subtitle_manager.file.v1.FileService.UploadFile:output_type -> subtitle_manager.file.v1.UploadFileResponse
	5,  // 31: subtitle_manager.file.v1.FileService.DownloadFile:output_type -> subtitle_manager.file.v1.DownloadFileResponse
	8,  // 32: subtitle_manager.file.v1.FileService.DeleteFile:output_type -> subtitle_manager.file.v1.DeleteFileResponse
	10, // 33: subtitle_manager.file.v1.FileService.GetFileInfo:output_type -> subtitle_manager.file.v1.GetFileInfoResponse
	12, // 34: subtitle_manager.file.v1.FileService.CopyFile:output_type -> subtitle_manager.file.v1.CopyFileResponse
	14, // 35: subtitle_manager.file.v1.FileService.MoveFile:output_type -> subtitle_manager.file.v1.MoveFileResponse
	17, // 36: subtitle_manager.file.v1.FileService.ListFiles:output_type -> subtitle_manager.file.v1.ListFilesResponse
	20, // 37: subtitle_manager.file.v1.FileService.UpdateFileMetadata:output_type -> subtitle_manager.file.v1.UpdateFileMetadataResponse
	23, // 38: subtitle_manager.file.v1.FileService.SearchFiles:output_type -> subtitle_manager.file.v1.SearchFilesResponse
	25, // 39: subtitle_manager.file.v1.FileService.GetStorageInfo:output_type -> subtitle_manager.file.v1.GetStorageInfoResponse
	28, // 40: subtitle_manager.file.v1.FileService.CleanupFiles:output_type -> subtitle_manager.file.v1.CleanupFilesResponse
	30, // 41: subtitle_manager.file.v1.FileService.HealthCheck:output_type -> subtitle_manager.file.v1.HealthCheckResponse
	30, // [30:42] is the sub-list for method output_type
	18, // [18:30] is the sub-list for method input_type
	18, // [18:18] is the sub-list for extension type_name
	18, // [18:18] is the sub-list for extension extendee
	0,  // [0:18] is the sub-list for field type_name
}

func init() { file_file_v1_file_service_proto_init() }
func file_file_v1_file_service_proto_init() {
	if File_file_v1_file_service_proto != nil {
		return
	}
	file_file_v1_file_service_proto_msgTypes[0].OneofWrappers = []any{
		(*UploadFileRequest_Metadata)(nil),
		(*UploadFileRequest_Chunk)(nil),
	}
	file_file_v1_file_service_proto_msgTypes[5].OneofWrappers = []any{
		(*DownloadFileResponse_FileInfo)(nil),
		(*DownloadFileResponse_Chunk)(nil),
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_file_v1_file_service_proto_rawDesc), len(file_file_v1_file_service_proto_rawDesc)),
			NumEnums:      0,
			NumMessages:   40,
			NumExtensions: 0,
			NumServices:   1,
		},
		GoTypes:           file_file_v1_file_service_proto_goTypes,
		DependencyIndexes: file_file_v1_file_service_proto_depIdxs,
		MessageInfos:      file_file_v1_file_service_proto_msgTypes,
	}.Build()
	File_file_v1_file_service_proto = out.File
	file_file_v1_file_service_proto_goTypes = nil
	file_file_v1_file_service_proto_depIdxs = nil
}
