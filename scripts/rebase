#!/bin/bash
# file: scripts/rebase

# Smart Git Rebase Launcher
# This script detects the best available rebase implementation and uses it

set -euo pipefail

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

# Script directory
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PYTHON_SCRIPT="$SCRIPT_DIR/rebase.py"
SHELL_SCRIPT="$SCRIPT_DIR/rebase.sh"

# Logging functions
log_info() {
    echo -e "${BLUE}[LAUNCHER]${NC} $1"
}

log_success() {
    echo -e "${GREEN}[LAUNCHER]${NC} $1"
}

log_warning() {
    echo -e "${YELLOW}[LAUNCHER]${NC} $1"
}

log_error() {
    echo -e "${RED}[LAUNCHER]${NC} $1"
}

# Check if Python 3 is available
check_python() {
    if command -v python3 >/dev/null 2>&1; then
        local version
        version=$(python3 --version 2>&1 | cut -d' ' -f2)
        local major_version
        major_version=$(echo "$version" | cut -d'.' -f1)
        local minor_version
        minor_version=$(echo "$version" | cut -d'.' -f2)

        # Require Python 3.7+
        if [[ "$major_version" -ge 3 && "$minor_version" -ge 7 ]]; then
            log_info "Found Python $version"
            return 0
        else
            log_warning "Python $version is too old (need 3.7+)"
            return 1
        fi
    else
        log_warning "Python 3 not found"
        return 1
    fi
}

# Try to install missing Python dependencies
install_python_deps() {
    local missing_deps=()

    # Check for required modules (none currently, but framework is here)
    # We deliberately keep the Python script dependency-free for maximum compatibility

    if [[ ${#missing_deps[@]} -eq 0 ]]; then
        log_info "All Python dependencies are satisfied"
        return 0
    fi

    log_info "Missing Python dependencies: ${missing_deps[*]}"

    # Try pip3 first
    if command -v pip3 >/dev/null 2>&1; then
        log_info "Attempting to install dependencies with pip3..."
        for dep in "${missing_deps[@]}"; do
            if pip3 install --user "$dep"; then
                log_success "Installed $dep"
            else
                log_error "Failed to install $dep with pip3"
                return 1
            fi
        done
        return 0
    fi

    # Try pip as fallback
    if command -v pip >/dev/null 2>&1; then
        log_info "Attempting to install dependencies with pip..."
        for dep in "${missing_deps[@]}"; do
            if pip install --user "$dep"; then
                log_success "Installed $dep"
            else
                log_error "Failed to install $dep with pip"
                return 1
            fi
        done
        return 0
    fi

    log_error "No pip found, cannot install dependencies"
    return 1
}

# Check if Python script can run
test_python_script() {
    if [[ ! -f "$PYTHON_SCRIPT" ]]; then
        log_error "Python script not found: $PYTHON_SCRIPT"
        return 1
    fi

    # Test if the script can import required modules
    if python3 -c "
import sys
import argparse
import json
import os
import subprocess
import time
from datetime import datetime
from enum import Enum
from pathlib import Path
from typing import Dict, List, Optional
print('Python dependencies OK')
" 2>/dev/null; then
        log_success "Python script dependencies verified"
        return 0
    else
        log_warning "Python script has missing dependencies"
        return 1
    fi
}

# Check if shell script can run
test_shell_script() {
    if [[ ! -f "$SHELL_SCRIPT" ]]; then
        log_error "Shell script not found: $SHELL_SCRIPT"
        return 1
    fi

    if [[ ! -x "$SHELL_SCRIPT" ]]; then
        log_info "Making shell script executable"
        chmod +x "$SHELL_SCRIPT"
    fi

    log_success "Shell script verified"
    return 0
}

# Determine which implementation to use
select_implementation() {
    local use_python=false
    local use_shell=false

    # Check Python availability
    if check_python >/dev/null 2>&1; then
        if test_python_script >/dev/null 2>&1; then
            use_python=true
        elif install_python_deps >/dev/null 2>&1 && test_python_script >/dev/null 2>&1; then
            use_python=true
        else
            log_warning "Python script cannot be used, falling back to shell" >&2
        fi
    fi

    # Check shell fallback
    if [[ "$use_python" == "false" ]]; then
        if test_shell_script >/dev/null 2>&1; then
            use_shell=true
        else
            log_error "Neither Python nor shell implementation is available" >&2
            exit 1
        fi
    fi

    # Return the selected implementation
    if [[ "$use_python" == "true" ]]; then
        echo "python"
    elif [[ "$use_shell" == "true" ]]; then
        echo "shell"
    else
        echo "none"
    fi
}

# Show help combining both implementations
show_combined_help() {
    cat << 'EOF'
Smart Git Rebase Launcher

This launcher automatically selects the best available rebase implementation:
1. Python version (preferred) - Full featured with intelligent conflict resolution
2. Shell version (fallback) - Compatible with minimal environments

Usage: rebase [OPTIONS] <target-branch>

OPTIONS:
    --mode MODE         Rebase mode: interactive, automated, smart (default: smart)
    -f, --force-push    Force push after successful rebase
    -d, --dry-run       Show what would be done without executing
    -v, --verbose       Enable verbose output
    -h, --help          Show this help message
    --implementation    Force specific implementation: python, shell, auto (default: auto)

EXAMPLES:
    rebase main                         # Smart rebase onto main
    rebase --mode automated main        # Fully automated rebase
    rebase --force-push main            # Rebase and force push
    rebase --dry-run main               # Preview what would happen
    rebase --implementation shell main  # Force shell version

MODES:
    interactive  - User-driven with prompts for conflicts
    automated    - Fully automated (AI/CI friendly)
    smart        - Intelligent automation with fallbacks (default)

CONFLICT RESOLUTION:
The rebase tool includes intelligent strategies for different file types:
- Documentation (*.md, docs/*): Prefer incoming changes
- Build/CI files (.github/*, Dockerfile*, etc.): Prefer incoming changes
- Package files (go.mod, package.json, etc.): Prefer incoming changes
- Configuration files (*.json, *.yml, etc.): Smart merge or prefer incoming
- Code files (*.go, *.js, *.py, etc.): Save both versions for manual review

RECOVERY:
If something goes wrong, the tool creates backup branches and provides
recovery instructions in the generated summary file.
EOF
}

# Main function
main() {
    local implementation="auto"
    local script_args=()

    # Parse launcher-specific arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            --implementation)
                implementation="$2"
                shift 2
                ;;
            -h|--help)
                show_combined_help
                exit 0
                ;;
            *)
                # Pass through to the actual script
                script_args+=("$1")
                shift
                ;;
        esac
    done

    # Validate implementation choice
    case "$implementation" in
        auto|python|shell)
            ;;
        *)
            log_error "Invalid implementation: $implementation"
            echo "Valid options: auto, python, shell"
            exit 1
            ;;
    esac

    log_info "Smart Git Rebase Launcher"

    # Select implementation
    local selected_impl=""
    if [[ "$implementation" == "auto" ]]; then
        selected_impl=$(select_implementation)
    elif [[ "$implementation" == "python" ]]; then
        if check_python && (test_python_script || (install_python_deps && test_python_script)); then
            selected_impl="python"
        else
            log_error "Python implementation not available"
            exit 1
        fi
    elif [[ "$implementation" == "shell" ]]; then
        if test_shell_script; then
            selected_impl="shell"
        else
            log_error "Shell implementation not available"
            exit 1
        fi
    fi

    # Execute the selected implementation
    case "$selected_impl" in
        python)
            log_success "Using Python implementation (full-featured)"
            if [[ ! -x "$PYTHON_SCRIPT" ]]; then
                chmod +x "$PYTHON_SCRIPT"
            fi
            exec python3 "$PYTHON_SCRIPT" "${script_args[@]}"
            ;;
        shell)
            log_success "Using Shell implementation (fallback)"
            exec "$SHELL_SCRIPT" "${script_args[@]}"
            ;;
        none)
            log_error "No suitable implementation found"
            exit 1
            ;;
        *)
            log_error "Unknown implementation selected: $selected_impl"
            exit 1
            ;;
    esac
}

# Make scripts executable if needed
if [[ -f "$PYTHON_SCRIPT" && ! -x "$PYTHON_SCRIPT" ]]; then
    chmod +x "$PYTHON_SCRIPT"
fi

if [[ -f "$SHELL_SCRIPT" && ! -x "$SHELL_SCRIPT" ]]; then
    chmod +x "$SHELL_SCRIPT"
fi

# Run main function
main "$@"
